import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import sql from '@/lib/db';
import { Transaction, accounts, categories, vendors } from '@/data/finance-data';
import { toast } from 'sonner';

// Define the structure of a transaction as it will be stored in the database
// Note: 'id' will be generated by the database, 'currency' will be 'USD' by default
interface DbTransaction {
  id: string;
  transfer_id?: string; // Snake_case for database columns
  date: string;
  account: string;
  currency: string;
  vendor: string;
  amount: number;
  remarks?: string;
  category: string;
}

// Helper to convert DB format to app format
const toAppTransaction = (dbTxn: DbTransaction): Transaction => ({
  id: dbTxn.id,
  transferId: dbTxn.transfer_id || undefined,
  date: dbTxn.date,
  account: dbTxn.account,
  currency: dbTxn.currency,
  vendor: dbTxn.vendor,
  amount: dbTxn.amount,
  remarks: dbTxn.remarks || undefined,
  category: dbTxn.category,
});

// Helper to convert app format to DB format
const toDbTransaction = (appTxn: Partial<Transaction>): Partial<DbTransaction> => ({
  id: appTxn.id,
  transfer_id: appTxn.transferId || null, // Use null for optional DB fields
  date: appTxn.date,
  account: appTxn.account,
  currency: appTxn.currency,
  vendor: appTxn.vendor,
  amount: appTxn.amount,
  remarks: appTxn.remarks || null,
  category: appTxn.category,
});

// Function to fetch all transactions from the database
const fetchTransactions = async (): Promise<Transaction[]> => {
  const dbTransactions = await sql<DbTransaction[]>`SELECT * FROM transactions ORDER BY date DESC, id DESC`;
  return dbTransactions.map(toAppTransaction);
};

// Function to add a new transaction (or a pair of transfer transactions)
const addTransactionToDb = async (
  transaction: Omit<Transaction, 'id' | 'currency' | 'transferId'> & { date: string }
): Promise<Transaction[]> => {
  const isTransfer = accounts.includes(transaction.vendor);
  const newTransactions: DbTransaction[] = [];

  if (isTransfer) {
    const transferId = `transfer_${Date.now()}`;
    const baseRemarks = transaction.remarks || "";
    const newAmount = Math.abs(transaction.amount);

    const debitTransaction: DbTransaction = {
      id: `txn_${Date.now()}_d`,
      transfer_id: transferId,
      date: new Date(transaction.date).toISOString(),
      account: transaction.account,
      currency: 'USD',
      vendor: transaction.vendor,
      amount: -newAmount,
      remarks: baseRemarks ? `${baseRemarks} (To ${transaction.vendor})` : `Transfer to ${transaction.vendor}`,
      category: 'Transfer',
    };

    const creditTransaction: DbTransaction = {
      id: `txn_${Date.now()}_c`,
      transfer_id: transferId,
      date: new Date(transaction.date).toISOString(),
      account: transaction.vendor, // Destination account
      currency: 'USD',
      vendor: transaction.account, // Source account
      amount: newAmount,
      remarks: baseRemarks ? `${baseRemarks} (From ${transaction.account})` : `Transfer from ${transaction.account}`,
      category: 'Transfer',
    };

    newTransactions.push(debitTransaction, creditTransaction);
  } else {
    const singleTransaction: DbTransaction = {
      id: `txn_${Date.now()}`,
      date: new Date(transaction.date).toISOString(),
      account: transaction.account,
      currency: 'USD',
      vendor: transaction.vendor,
      amount: transaction.amount,
      remarks: transaction.remarks || null,
      category: transaction.category,
    };
    newTransactions.push(singleTransaction);
  }

  // Insert all new transactions
  const inserted = await sql<DbTransaction[]>`
    INSERT INTO transactions ${sql(newTransactions, 'id', 'transfer_id', 'date', 'account', 'currency', 'vendor', 'amount', 'remarks', 'category')}
    RETURNING *;
  `;
  return inserted.map(toAppTransaction);
};

// Function to update an existing transaction (or a pair of transfer transactions)
const updateTransactionInDb = async (updatedTransaction: Transaction): Promise<Transaction[]> => {
  const originalTransaction = (await sql<DbTransaction[]>`SELECT * FROM transactions WHERE id = ${updatedTransaction.id}`)[0];

  if (!originalTransaction) {
    throw new Error('Original transaction not found.');
  }

  const wasTransfer = !!originalTransaction.transfer_id;
  const isNowTransfer = accounts.includes(updatedTransaction.vendor);

  // Case 1: Editing a regular transaction to become a transfer
  if (!wasTransfer && isNowTransfer) {
    // Delete the original transaction
    await sql`DELETE FROM transactions WHERE id = ${originalTransaction.id}`;
    // Add new transfer transactions
    return addTransactionToDb(updatedTransaction);
  }

  // Case 2: Editing a transfer to become a regular transaction
  if (wasTransfer && !isNowTransfer) {
    // Delete all transactions related to the transferId
    await sql`DELETE FROM transactions WHERE transfer_id = ${originalTransaction.transfer_id}`;
    // Add a new regular transaction
    return addTransactionToDb({ ...updatedTransaction, amount: -Math.abs(updatedTransaction.amount) }); // Ensure expense for regular
  }

  // Case 3: Editing a transfer (remains a transfer)
  if (wasTransfer && isNowTransfer) {
    const sibling = (await sql<DbTransaction[]>`SELECT * FROM transactions WHERE transfer_id = ${originalTransaction.transfer_id} AND id != ${originalTransaction.id}`)[0];
    if (!sibling) {
      throw new Error('Sibling transfer transaction not found.');
    }

    const oldDebit = originalTransaction.amount < 0 ? originalTransaction : sibling;
    const oldCredit = originalTransaction.amount < 0 ? sibling : originalTransaction;

    const newDate = new Date(updatedTransaction.date).toISOString();
    const newAmount = Math.abs(updatedTransaction.amount);
    const baseRemarks = updatedTransaction.remarks?.split(" (From ")[0].split(" (To ")[0] || "";

    const newDebitAccount = updatedTransaction.account;
    const newCreditAccount = updatedTransaction.vendor;

    const newDebit: DbTransaction = {
      ...oldDebit,
      date: newDate,
      account: newDebitAccount,
      vendor: newCreditAccount,
      amount: -newAmount,
      category: 'Transfer',
      remarks: baseRemarks ? `${baseRemarks} (To ${newCreditAccount})` : `Transfer to ${newCreditAccount}`,
    };

    const newCredit: DbTransaction = {
      ...oldCredit,
      date: newDate,
      account: newCreditAccount,
      vendor: newDebitAccount,
      amount: newAmount,
      category: 'Transfer',
      remarks: baseRemarks ? `${baseRemarks} (From ${newDebitAccount})` : `Transfer from ${newDebitAccount}`,
    };

    // Update both transfer transactions
    await sql`
      UPDATE transactions SET
        date = ${newDebit.date},
        account = ${newDebit.account},
        vendor = ${newDebit.vendor},
        amount = ${newDebit.amount},
        remarks = ${newDebit.remarks},
        category = ${newDebit.category}
      WHERE id = ${newDebit.id}
    `;
    await sql`
      UPDATE transactions SET
        date = ${newCredit.date},
        account = ${newCredit.account},
        vendor = ${newCredit.vendor},
        amount = ${newCredit.amount},
        remarks = ${newCredit.remarks},
        category = ${newCredit.category}
      WHERE id = ${newCredit.id}
    `;
    return [toAppTransaction(newDebit), toAppTransaction(newCredit)];
  }

  // Case 4: Editing a regular transaction (remains regular)
  const dbUpdatedTransaction = toDbTransaction(updatedTransaction);
  const updated = await sql<DbTransaction[]>`
    UPDATE transactions SET
      date = ${dbUpdatedTransaction.date},
      account = ${dbUpdatedTransaction.account},
      vendor = ${dbUpdatedTransaction.vendor},
      amount = ${dbUpdatedTransaction.amount},
      remarks = ${dbUpdatedTransaction.remarks},
      category = ${dbUpdatedTransaction.category}
    WHERE id = ${dbUpdatedTransaction.id}
    RETURNING *;
  `;
  return updated.map(toAppTransaction);
};

// Function to delete a transaction (or a pair of transfer transactions)
const deleteTransactionFromDb = async (transactionId: string, transferId?: string): Promise<void> => {
  if (transferId) {
    await sql`DELETE FROM transactions WHERE transfer_id = ${transferId}`;
  } else {
    await sql`DELETE FROM transactions WHERE id = ${transactionId}`;
  }
};

export const useTransactionsDb = () => {
  const queryClient = useQueryClient();

  // Query to fetch all transactions
  const { data: transactions, isLoading, isError, error } = useQuery<Transaction[], Error>({
    queryKey: ['transactions'],
    queryFn: fetchTransactions,
  });

  // Mutation to add a transaction
  const addMutation = useMutation<Transaction[], Error, Omit<Transaction, 'id' | 'currency' | 'transferId'> & { date: string }>({
    mutationFn: addTransactionToDb,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['transactions'] });
      toast.success('Transaction added successfully!');
    },
    onError: (err) => {
      toast.error(`Failed to add transaction: ${err.message}`);
    },
  });

  // Mutation to update a transaction
  const updateMutation = useMutation<Transaction[], Error, Transaction>({
    mutationFn: updateTransactionInDb,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['transactions'] });
      toast.success('Transaction updated successfully!');
    },
    onError: (err) => {
      toast.error(`Failed to update transaction: ${err.message}`);
    },
  });

  // Mutation to delete a transaction
  const deleteMutation = useMutation<void, Error, { transactionId: string; transferId?: string }>({
    mutationFn: ({ transactionId, transferId }) => deleteTransactionFromDb(transactionId, transferId),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['transactions'] });
      toast.success('Transaction deleted successfully!');
    },
    onError: (err) => {
      toast.error(`Failed to delete transaction: ${err.message}`);
    },
  });

  return {
    transactions: transactions || [],
    isLoading,
    isError,
    error,
    addTransaction: addMutation.mutate,
    updateTransaction: updateMutation.mutate,
    deleteTransaction: deleteMutation.mutate,
  };
};